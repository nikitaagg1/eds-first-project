package com.xyz.shop.core.service.impl;

import static com.xyz.shop.core.constants.Constants.CURRENCY_CODE;
import static com.xyz.shop.core.constants.Constants.CURRENCY_CODE_KEY;
import static com.xyz.shop.core.constants.Constants.CUSTOMER_FIRST_NAME;
import static com.xyz.shop.core.constants.Constants.CUSTOMER_LAST_NAME;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_CITY;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_COUNTRY;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_PHONENUMBER;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_POSTALCODE;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_STATE;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_STREET;
import static com.xyz.shop.core.constants.Constants.DEALER_EMAIL;
import static com.xyz.shop.core.constants.Constants.DEALER_NAME_PARAM;
import static com.xyz.shop.core.constants.Constants.DISPLAY;
import static com.xyz.shop.core.constants.Constants.DOMAIN_URL;
import static com.xyz.shop.core.constants.Constants.EMAIL_SUBJECT;
import static com.xyz.shop.core.constants.Constants.FILTER_DEALER_KEY;
import static com.xyz.shop.core.constants.Constants.MAX_DISPLAY_PRICE;
import static com.xyz.shop.core.constants.Constants.MAX_STRIKEOUT_PRICE;
import static com.xyz.shop.core.constants.Constants.ORDER_CONFIRMATION_EMAIL_SUBJECT;
import static com.xyz.shop.core.constants.Constants.ORDER_NUMBER;
import static com.xyz.shop.core.constants.Constants.ORDER_PRODUCTS_DATA;
import static com.xyz.shop.core.constants.Constants.ORDER_PROMO_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_SHIPPING_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_SUBTOTAL;
import static com.xyz.shop.core.constants.Constants.ORDER_TAX_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_TOTAL_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORIGINAL;
import static com.xyz.shop.core.constants.Constants.PRICE_TYPE;
import static com.xyz.shop.core.constants.Constants.PRICE_TYPE_KEY;
import static com.xyz.shop.core.constants.Constants.RESULTS;
import static com.xyz.shop.core.constants.Constants.SHOP_PUBLISH_DOMAIN;
import static com.xyz.shop.core.constants.Constants.STRIKE_OUT;
import static com.xyz.shop.core.constants.Constants.TO_EMAIL_ADDRESS;
import static com.xyz.shop.core.constants.Constants.ZERO;
import static com.xyz.shop.core.utilities.GlobalUtil.getI18nValue;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.generateCategoryQueryParams;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.generateProductDetailResponse;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.getFormattedPhoneNumber;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.getProductPrice;
import static com.xyz.shop.core.utilities.ServletUtility.convertObjectToJSON;
import static org.apache.sling.api.servlets.HttpConstants.METHOD_GET;

import java.net.URISyntaxException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.adobe.granite.crypto.CryptoException;
import com.adobe.granite.crypto.CryptoSupport;
import com.xyz.shop.core.config.OneShopApiConfigurationService;
import com.xyz.shop.core.config.ProxyConfigurationService;
import com.xyz.shop.core.constants.Constants;
import com.xyz.shop.core.exception.GenericException;
import com.xyz.shop.core.models.impl.bean.ProductDetails;
import com.xyz.shop.core.service.OneShopService;
import com.xyz.shop.core.service.RestServiceExecute;
import com.xyz.shop.core.service.beans.RestServiceConfiguration;
import com.xyz.shop.core.utilities.GlobalUtil;
import com.xyz.shop.core.utilities.JsonPathQuery;
import com.xyz.shop.core.utilities.JsonUtil;
import com.xyz.shop.core.utilities.OneShopResponseUtil;
import com.xyz.shop.core.utilities.ResourceResolverUtility;
import com.xyz.shop.core.utilities.RestRequestUtil;
import com.xyz.shop.core.utilities.RestServiceRequest;
import com.day.cq.commons.Externalizer;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import net.minidev.json.JSONArray;


@Component(service = OneShopService.class, immediate = true, enabled = true)
public class OneShopServiceImpl implements OneShopService {

    private static final Logger LOG = LoggerFactory.getLogger(OneShopServiceImpl.class);

    @Reference
    ProxyConfigurationService proxyConfigService;

    @Reference
    RestServiceExecute restServiceExecute;

    @Reference
    ResourceResolverFactory resolverFactory;
    @Reference
    OneShopApiConfigurationService oneShopApiConfig;
    @Reference
    CryptoSupport cryptoSupport;

    @Reference
    Externalizer externalizer;

    
    @Override
    public void setProductVariants(final String dealerCode, final ProductDetails productCard,
            final JsonObject serviceResponse, final String brand) throws GenericException {

        LOG.debug("inside setProductVariants method");
        if (productCard.getItemNumber().contains("xx")) {
            try {
                final HashMap<String, Object> prices = new HashMap<>();
                final StringBuilder stringBuilder = new StringBuilder();
                final List<String> typeKeyList = CollectionUtils.isNotEmpty(productCard.getTypeKey())
                        ? productCard.getTypeKey()
                        : new ArrayList<>();
                LOG.debug("setting variants for product {}", productCard.getItemNumber());
                final String productVariantsApiEndpoint = GlobalUtil.getConfig(brand,
                        oneShopApiConfig.getProductProjectionApiEndpoint())
                        + GlobalUtil.getConfig(brand, oneShopApiConfig.getProductVariants());
                final String productFilterByVariantsEndpoint = MessageFormat.format(productVariantsApiEndpoint,
                        productCard.getItemNumber());
                LOG.debug("productFilterByVariantsEndpoint{}", productFilterByVariantsEndpoint);
                final String[] productQueryParams = productFilterByVariantsEndpoint
                        .split(Constants.QUESTION_MARK_DELIMITER);
                final HashMap<String, String> queryMap = (HashMap<String, String>) generateCategoryQueryParams(
                        productQueryParams);
                final RestServiceConfiguration serviceConfig = getServiceConfig(brand);
                serviceConfig.setServiceEndpoint(productQueryParams[0]);
                final RestServiceRequest variantRestServiceRequest = new RestServiceRequest(serviceConfig, queryMap);
                final JsonObject variantsResponse = executeOneShopGetRequest(variantRestServiceRequest, brand);
                if (ObjectUtils.isNotEmpty(variantsResponse) && (serviceResponse.size() > 0)) {
                    setVariantInformation(dealerCode, productCard, serviceResponse, prices, stringBuilder, typeKeyList,
                            variantsResponse, brand);
                }
            } catch (final CryptoException cryptoException) {
                throw new GenericException("Crypto Exception while getting products count for categories",
                        cryptoException);
            }

        }

        LOG.debug("Exiting setProductVariants method");

    }

    /**
     * This method will return RestServiceConfiguration object.
     *
     * @return
     */
    public RestServiceConfiguration getServiceConfig(final String brand) throws CryptoException {

        LOG.debug("inside getServiceConfig method");
        final RestServiceConfiguration serviceConfig = new RestServiceConfiguration();
        serviceConfig.setXApiKey(cryptoSupport.isProtected(GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()))
                ? cryptoSupport.unprotect(GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()))
                : GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()));
        serviceConfig.setMarket(GlobalUtil.getConfig(brand, oneShopApiConfig.getMarket()));
        serviceConfig.setEcpType(GlobalUtil.getConfig(brand, oneShopApiConfig.getEcpType()));
        serviceConfig.setHttpMethod(METHOD_GET);
        serviceConfig.setServiceUrl(GlobalUtil.getConfig(brand, oneShopApiConfig.getServiceUrl()));

        return serviceConfig;
    }

    /**
     * This method will fetch dealer details from oneshop based on dealer key
     *
     * @param orderEmailParams
     * @param dealerKey
     * @throws CryptoException
     * @throws GenericException
     */
    public void setDealerDetails(final Map<String, String> orderEmailParams, final String dealerKey,
            final String brand) throws CryptoException, GenericException {

        LOG.debug("Inside setDealerDetails method");
        final String channelsApiEndPoint = MessageFormat
                .format(GlobalUtil.getConfig(brand, oneShopApiConfig.getChannels()), ZERO)
                + MessageFormat.format(FILTER_DEALER_KEY, dealerKey);
        final RestServiceConfiguration channelsServiceConfig = getServiceConfig(brand);
        channelsServiceConfig.setServiceEndpoint(channelsApiEndPoint);
        final RestServiceRequest restServiceRequestChannel = new RestServiceRequest(channelsServiceConfig, null);
        final JsonObject channelsServiceResponse = executeOneShopGetRequest(restServiceRequestChannel, brand);
        if ((null != channelsServiceResponse) && ObjectUtils.isNotEmpty(channelsServiceResponse)) {
            orderEmailParams.put(DEALER_NAME_PARAM,
                    JsonUtil.getStringValueFromJson(channelsServiceResponse, JsonPathQuery.DEALER_NAME.query()));
            orderEmailParams.put(DEALER_EMAIL,
                    JsonUtil.getStringValueFromJson(channelsServiceResponse, JsonPathQuery.DEALER_EMAIL.query()));
            orderEmailParams.put(DEALER_ADDRESS_STREET, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_STREET.query()));
            orderEmailParams.put(DEALER_ADDRESS_POSTALCODE, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_POSTALCODE.query()));
            orderEmailParams.put(DEALER_ADDRESS_CITY, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_CITY.query()));
            orderEmailParams.put(DEALER_ADDRESS_STATE, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_STATE.query()));
            orderEmailParams.put(DEALER_ADDRESS_COUNTRY, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_COUNTRY.query()));
            final String dealerPhoneNumber = JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_PHONENUMBER.query());
            orderEmailParams.put(DEALER_ADDRESS_PHONENUMBER, getFormattedPhoneNumber(dealerPhoneNumber));
        }
    }

    /**
     * This method will set the LTO Price Range for Master Variant.
     *
     * @param productCard
     */
    public void setLtoPriceRangeProdDetailsForMasterVariant(final ProductDetails productCard) {

        LOG.debug("inside setLtoPriceRangeProdDetailsForMasterVariant method");
        final List<ProductDetails> variants = productCard.getVariants();
        int ltoMin = Integer.MAX_VALUE;
        int ltoMax = 0;
        boolean childAvailable = false;
        for (final ProductDetails variant : variants) {
            if (variant.getItemNumber().contains("xx") && (variant.getStrikeoutMaxCentAmount() != null)
                    && (variant.getStrikeoutMinCentAmount() != null)) {
                if (ltoMin > variant.getStrikeoutMinCentAmount()) {
                    ltoMin = variant.getStrikeoutMinCentAmount();
                }
                if ((ltoMax < variant.getStrikeoutMaxCentAmount())) {
                    ltoMax = variant.getStrikeoutMaxCentAmount();
                }
                productCard.setStrikeoutMaxCentAmount(ltoMax);
                productCard.setStrikeoutMinCentAmount(ltoMin);
                // these fields were only used for calculation hence setting these fields null
                // as not needed to send back in json.
                variant.setStrikeoutMaxCentAmount(null);
                variant.setStrikeoutMinCentAmount(null);
            }
            if (variant.isAvailability()) {
                childAvailable = true;
            }
        }
        // these fields were only used for calculation hence setting these fields null
        // as not needed to send back in json.
        productCard.setStrikeoutMaxCentAmount(null);
        productCard.setStrikeoutMinCentAmount(null);
        productCard.setAvailability(childAvailable);
    }

    /**
     * This method will set max min price for strikeout.
     *
     * @param productCard
     * @param productVariantCard
     */
    public void setMaxMinAmountForLTO(final ProductDetails productCard, final ProductDetails productVariantCard,
            int minStrikeout, int maxStrikeout) {

        LOG.debug("inside setMaxMinAmountForLTO method");
        if (minStrikeout > productVariantCard.getStrikeoutCentAmount()) {
            minStrikeout = productVariantCard.getStrikeoutCentAmount();
        }
        if ((maxStrikeout < productVariantCard.getStrikeoutCentAmount()) && !productCard.isChildMultiSelect()) {
            maxStrikeout = productVariantCard.getStrikeoutCentAmount();
        } else if (productCard.isChildMultiSelect()) {
            maxStrikeout = maxStrikeout + productVariantCard.getStrikeoutCentAmount();
        }

        productCard.setStrikeoutMaxCentAmount(maxStrikeout);
        productCard.setStrikeoutMinCentAmount(minStrikeout);
        productVariantCard.setStrikeoutCentAmount(null);
    }

    /**
     * This method will set the max and min price for variant levels.
     *
     * @param productCard
     * @param productVariantCard
     */
    public void setMaxMinPriceForVariant(final ProductDetails productCard, final ProductDetails productVariantCard,
            int min, int max) {

        LOG.debug("inside setMaxMinPriceForVariant method");
        if (min > productVariantCard.getCentAmount()) {
            min = productVariantCard.getCentAmount();
        }
        if ((max < productVariantCard.getCentAmount()) && !productCard.isChildMultiSelect()) {
            max = productVariantCard.getCentAmount();
        } else if (productCard.isChildMultiSelect()) {
            max = max + productVariantCard.getCentAmount();
        }

        productCard.setMaxCentAmount(max);
        productCard.setMinCentAmount(min);

        // these fields were only used for calculation hence setting these fields null
        // as not needed to send back in json.
        productVariantCard.setCentAmount(null);
    }

    /**
     * This method will set Price range for parent level.
     *
     * @param productCard
     */
    public void setPriceRangeForParentLevel(final ProductDetails productCard, final HashMap<String, Object> prices) {

        LOG.debug("inside setPriceRangeForParentLevel method");
        if ((productCard.getMinCentAmount() != null) && (productCard.getMaxCentAmount() != null)
                && productCard.getMaxCentAmount().equals(productCard.getMinCentAmount())) {
            prices.put(DISPLAY, productCard.getMaxCentAmount());
        } else if ((productCard.getMinCentAmount() != null) && (productCard.getMaxCentAmount() != null)
                && !productCard.getMaxCentAmount().equals(productCard.getMinCentAmount())) {
            prices.put(DISPLAY, productCard.getMinCentAmount());
            prices.put(MAX_DISPLAY_PRICE, productCard.getMaxCentAmount());
        }
        setStrikeoutPriceRangeForParentLevel(productCard, prices);
        productCard.setPrices(prices);

    }

    /**
     * This method will set Strikeout Price range for parent level.
     *
     * @param productCard
     */
    public void setStrikeoutPriceRangeForParentLevel(final ProductDetails productCard,
            final HashMap<String, Object> prices) {

        LOG.debug("inside setStrikeoutPriceRangeForParentLevel method");
        if ((productCard.getStrikeoutMinCentAmount() != null) && (productCard.getStrikeoutMaxCentAmount() != null)
                && productCard.getStrikeoutMaxCentAmount().equals(productCard.getStrikeoutMinCentAmount())) {
            prices.put(STRIKE_OUT, productCard.getStrikeoutMaxCentAmount());
        } else if ((productCard.getStrikeoutMinCentAmount() != null)
                && (productCard.getStrikeoutMaxCentAmount() != null)
                && !productCard.getStrikeoutMaxCentAmount().equals(productCard.getStrikeoutMinCentAmount())) {
            prices.put(STRIKE_OUT, productCard.getMinCentAmount());
            prices.put(MAX_STRIKEOUT_PRICE, productCard.getMaxCentAmount());
        }
    }

   

}
