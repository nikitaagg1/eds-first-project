package com.xyz.shop.core.service.impl;

import static com.xyz.shop.core.constants.Constants.CURRENCY_CODE;
import static com.xyz.shop.core.constants.Constants.CURRENCY_CODE_KEY;
import static com.xyz.shop.core.constants.Constants.CUSTOMER_FIRST_NAME;
import static com.xyz.shop.core.constants.Constants.CUSTOMER_LAST_NAME;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_CITY;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_COUNTRY;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_PHONENUMBER;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_POSTALCODE;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_STATE;
import static com.xyz.shop.core.constants.Constants.DEALER_ADDRESS_STREET;
import static com.xyz.shop.core.constants.Constants.DEALER_EMAIL;
import static com.xyz.shop.core.constants.Constants.DEALER_NAME_PARAM;
import static com.xyz.shop.core.constants.Constants.DISPLAY;
import static com.xyz.shop.core.constants.Constants.DOMAIN_URL;
import static com.xyz.shop.core.constants.Constants.EMAIL_SUBJECT;
import static com.xyz.shop.core.constants.Constants.FILTER_DEALER_KEY;
import static com.xyz.shop.core.constants.Constants.MAX_DISPLAY_PRICE;
import static com.xyz.shop.core.constants.Constants.MAX_STRIKEOUT_PRICE;
import static com.xyz.shop.core.constants.Constants.ORDER_CONFIRMATION_EMAIL_SUBJECT;
import static com.xyz.shop.core.constants.Constants.ORDER_NUMBER;
import static com.xyz.shop.core.constants.Constants.ORDER_PRODUCTS_DATA;
import static com.xyz.shop.core.constants.Constants.ORDER_PROMO_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_SHIPPING_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_SUBTOTAL;
import static com.xyz.shop.core.constants.Constants.ORDER_TAX_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORDER_TOTAL_AMOUNT;
import static com.xyz.shop.core.constants.Constants.ORIGINAL;
import static com.xyz.shop.core.constants.Constants.PRICE_TYPE;
import static com.xyz.shop.core.constants.Constants.PRICE_TYPE_KEY;
import static com.xyz.shop.core.constants.Constants.RESULTS;
import static com.xyz.shop.core.constants.Constants.SHOP_PUBLISH_DOMAIN;
import static com.xyz.shop.core.constants.Constants.STRIKE_OUT;
import static com.xyz.shop.core.constants.Constants.TO_EMAIL_ADDRESS;
import static com.xyz.shop.core.constants.Constants.ZERO;
import static com.xyz.shop.core.utilities.GlobalUtil.getI18nValue;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.generateCategoryQueryParams;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.generateProductDetailResponse;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.getFormattedPhoneNumber;
import static com.xyz.shop.core.utilities.OneShopResponseUtil.getProductPrice;
import static com.xyz.shop.core.utilities.ServletUtility.convertObjectToJSON;
import static org.apache.sling.api.servlets.HttpConstants.METHOD_GET;

import java.net.URISyntaxException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.adobe.granite.crypto.CryptoException;
import com.adobe.granite.crypto.CryptoSupport;
import com.xyz.shop.core.config.OneShopApiConfigurationService;
import com.xyz.shop.core.config.ProxyConfigurationService;
import com.xyz.shop.core.constants.Constants;
import com.xyz.shop.core.exception.GenericException;
import com.xyz.shop.core.models.impl.bean.ProductDetails;
import com.xyz.shop.core.service.OneShopService;
import com.xyz.shop.core.service.RestServiceExecute;
import com.xyz.shop.core.service.beans.RestServiceConfiguration;
import com.xyz.shop.core.utilities.GlobalUtil;
import com.xyz.shop.core.utilities.JsonPathQuery;
import com.xyz.shop.core.utilities.JsonUtil;
import com.xyz.shop.core.utilities.OneShopResponseUtil;
import com.xyz.shop.core.utilities.ResourceResolverUtility;
import com.xyz.shop.core.utilities.RestRequestUtil;
import com.xyz.shop.core.utilities.RestServiceRequest;
import com.day.cq.commons.Externalizer;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import net.minidev.json.JSONArray;


@Component(service = Test2Service.class, immediate = true, enabled = true)
public class Test2ServiceImpl implements Test2Service {

    private static final Logger LOG = LoggerFactory.getLogger(OneShopServiceImpl.class);

    @Reference
    ProxyConfigurationService proxyConfigService;

    @Reference
    RestServiceExecute restServiceExecute;

    @Reference
    ResourceResolverFactory resolverFactory;
    @Reference
    OneShopApiConfigurationService oneShopApiConfig;
    @Reference
    CryptoSupport cryptoSupport;

    @Reference
    Externalizer externalizer;

    /**
     * This method will perform HTTP GET request on OneShop.
     *
     * @param serviceRequest
     *            - REST request containing different parameters, header, config
     *            required for invoking OneShop API.
     *
     * @return response received from OneShop.
     * @throws GenericException
     *             when invoking RestServiceExecute executeGetRequest method
     */
    @Override
    public JsonObject executeOneShopGetRequest(final RestServiceRequest serviceRequest, final String brand)
            throws GenericException {

        Map<String, String> encodedParamMap = new HashMap<>();
        String serviceUrl = StringUtils.EMPTY;
        final JsonObject responseJson;

        try {

            if (!MapUtils.isEmpty(serviceRequest.getRequestParams())) {
                encodedParamMap = RestRequestUtil.getEncodedParamMap(serviceRequest);
                serviceUrl = RestRequestUtil.getUpdatedServiceUrl(serviceRequest.getServiceConfiguration(),
                        encodedParamMap);
            } else {
                serviceUrl = RestRequestUtil.getUpdatedServiceUrl(serviceRequest.getServiceConfiguration());
            }

            LOG.info("Service URL with params for HTTP Get call {}", serviceUrl);

            final Map<String, String> headers = new HashMap<>();
            headers.put(Constants.ACCEPT, Constants.ACCEPT_HEADER);
            headers.put(Constants.ACCEPT_ENCODING, Constants.ACCEPT_ENCODING_HEADER);
            headers.put(Constants.X_API_KEY, serviceRequest.getServiceConfiguration().getXApiKey());

            final URIBuilder builder = new URIBuilder(serviceUrl);
            final HttpGet httpGet = new HttpGet(builder.build());
            RestRequestUtil.setHeaders(httpGet, headers);
            final long startTime = System.currentTimeMillis();
            final String responseBody = restServiceExecute.executeGetRequest(httpGet, true);
            LOG.info(Constants.SERVICE_TIME_LOG, serviceUrl, ((System.currentTimeMillis() - startTime) / 1000),
                    Thread.currentThread().getId());
            responseJson = new JsonParser().parse(responseBody).getAsJsonObject();

        } catch (

        final URISyntaxException uriSyntaxException) {
            throw new GenericException("URISyntaxException while invoking OneShop", uriSyntaxException);
        }
        return responseJson;
    }

    /**
     * This method will fetch pdp response from oneshop.
     */
    @Override
    public ProductDetails fetchProductDetails(final SlingHttpServletRequest request, final String productKey,
            final String dealerCode, final String brand) throws GenericException {

        LOG.debug("inside productDetails method");
        ProductDetails productCard = new ProductDetails();
        try {

            final String productApiEndpoint = GlobalUtil.getConfig(brand,
                    oneShopApiConfig.getProductProjectionApiEndpoint())
                    + GlobalUtil.getConfig(brand, oneShopApiConfig.getFilterByProductKeyQuery());
            final String productFilterByKeyEndpoint = MessageFormat.format(productApiEndpoint, productKey);
            LOG.debug("productFilterByKeyEndpoint{}", productFilterByKeyEndpoint);
            final RestServiceConfiguration serviceConfig = getServiceConfig(brand);
            serviceConfig.setServiceEndpoint(productFilterByKeyEndpoint);
            final RestServiceRequest restServiceRequest = new RestServiceRequest(serviceConfig, null);
            JsonObject serviceResponse;
            serviceResponse = executeOneShopGetRequest(restServiceRequest, brand);
            if ((null != serviceResponse) && ObjectUtils.isNotEmpty(serviceResponse)) {
                final Map<String, String> colorMap = OneShopResponseUtil.getColorMapping(resolverFactory, request,
                        brand);
                if (!MapUtils.isEmpty(colorMap)) {
                    OneShopResponseUtil.updateColorMapping(colorMap);
                }
                productCard = generateProductDetailResponse(serviceResponse);
                setDealerPrice(dealerCode, brand, productCard);
                final String brandOrginal = brand + ORIGINAL;
                productCard.setPreTitle(getI18nValue(request, brandOrginal));
                setProductVariants(dealerCode, productCard, serviceResponse, brand);
                if (CollectionUtils.isNotEmpty(productCard.getVariants())) {
                    setPriceRangeProdDetailsForMasterVariant(productCard);
                }
                productCard.setCentAmount(null);
                productCard.setStrikeoutCentAmount(null);

            }
        } catch (final CryptoException e) {
            throw new GenericException("Exception while fetchProductDetails", e);

        }
        LOG.debug("exiting productDetails method");
        return productCard;
    }

    /**
     * This method will fetch dealer price from oneshop standalone price Api.
     */
    @Override
    public int getDealerPrice(final String brand, final String dealerCode, final String sku) throws GenericException {

        LOG.debug("Inside getDealerPrice method for sku{}, dealerCode{}", sku, dealerCode);
        JsonObject serviceResponse = new JsonObject();
        int dealerPrice = ZERO;
        try {
            final String productApiEndpoint = GlobalUtil.getConfig(brand,
                    oneShopApiConfig.getProductStandAlonePriceApiEndpoint());
            final String dealerKey = sku + "-" + dealerCode;
            final String productStandAlonePriceApiEndpoint = MessageFormat.format(productApiEndpoint, dealerKey);
            LOG.debug("productStandAlonePriceApiEndpoint{}", productStandAlonePriceApiEndpoint);
            RestServiceConfiguration serviceConfig;
            serviceConfig = getServiceConfig(brand);
            serviceConfig.setServiceEndpoint(productStandAlonePriceApiEndpoint);
            final RestServiceRequest restServiceRequest = new RestServiceRequest(serviceConfig, null);
            serviceResponse = executeOneShopGetRequest(restServiceRequest, brand);
			if ((null != serviceResponse) && ObjectUtils.isNotEmpty(serviceResponse)) {
				if (serviceResponse.getAsJsonArray(RESULTS) != null && serviceResponse.getAsJsonArray(RESULTS).size() > ZERO) {
					final JSONArray dealerPriceArray = JsonUtil.getArrayValueFromJson(serviceResponse,
							String.format(JsonPathQuery.GET_DEALER_PRICE.query(), dealerKey));
					dealerPrice = !dealerPriceArray.isEmpty() ? (Integer) dealerPriceArray.get(ZERO) : ZERO;
					LOG.debug("dealerPrice{}", dealerPrice);
				}
			}
        } catch (final CryptoException e) {
            throw new GenericException("Exception while fetching Product Dealer Prices", e);

        }
        return dealerPrice;
    }

    @Override
    public Map<String, String> getOrderEmailParameters(final String orderId, final String emailAddress,
            final String brand) throws GenericException {

        LOG.debug("Inside getOrderEmailParameters method:: orderId {}:: emailAddress {}", orderId, emailAddress);
        final Map<String, String> orderEmailParams = new HashMap<>();
        try (final ResourceResolver resourceResolver = ResourceResolverUtility.getResourceResolver(resolverFactory)) {
            // Adding delay in order to wait for order number to be created in oneshop
            // system.
            TimeUnit.SECONDS.sleep(10);
            orderEmailParams.put(EMAIL_SUBJECT, ORDER_CONFIRMATION_EMAIL_SUBJECT);
            final String orderApiEndPoint = MessageFormat
                    .format(GlobalUtil.getConfig(brand, oneShopApiConfig.getOrderDetails()), orderId);
            final RestServiceConfiguration serviceConfig = getServiceConfig(brand);
            serviceConfig.setServiceEndpoint(orderApiEndPoint);
            final RestServiceRequest restServiceRequest = new RestServiceRequest(serviceConfig, null);
            final JsonObject serviceResponse = executeOneShopGetRequest(restServiceRequest, brand);
            if ((null != serviceResponse) && ObjectUtils.isNotEmpty(serviceResponse)) {
                orderEmailParams.put(CUSTOMER_FIRST_NAME,
                        JsonUtil.getStringValueFromJson(serviceResponse, JsonPathQuery.USER_FIRST_NAME.query()));
                orderEmailParams.put(CUSTOMER_LAST_NAME,
                        JsonUtil.getStringValueFromJson(serviceResponse, JsonPathQuery.USER_LAST_NAME.query()));
                orderEmailParams.put(ORDER_NUMBER,
                        JsonUtil.getStringValueFromJson(serviceResponse, JsonPathQuery.ORDER_NUMBER.query()));
                orderEmailParams.put(TO_EMAIL_ADDRESS,
                        JsonUtil.getStringValueFromJson(serviceResponse, JsonPathQuery.USER_EMAIL.query()));
                final int totalTax = JsonUtil.getIntValueFromJson(serviceResponse,
                        JsonPathQuery.ORDER_TAX_AMOUNT.query());
                final int totalProductPrice = JsonUtil.getIntValueFromJson(serviceResponse,
                        JsonPathQuery.ORDER_TOTAL_PRICE.query());
                final int totalAmount = JsonUtil.getIntValueFromJson(serviceResponse,
                        JsonPathQuery.ORDER_TOTAL_AMOUNT.query());
                final int shippingAmount = JsonUtil.getIntValueFromJson(serviceResponse,
                        JsonPathQuery.ORDER_SHIPPING_AMOUNT.query());
                orderEmailParams.put(ORDER_TAX_AMOUNT, getProductPrice(totalTax));
                orderEmailParams.put(ORDER_TOTAL_AMOUNT, getProductPrice(totalAmount));
                orderEmailParams.put(ORDER_SHIPPING_AMOUNT, getProductPrice(shippingAmount));
                final List<JSONArray> productList = JsonUtil.getJsonArrayListFromJson(serviceResponse,
                        JsonPathQuery.ORDER_LINE_ITEMS.query());
                final String dealerKey = JsonUtil.getStringValueFromJson(serviceResponse,
                        JsonPathQuery.ORDER_DEALER_KEY.query());

                final StringBuilder htmlBuilder = new StringBuilder();
                int discountAmount = 0;
                if (CollectionUtils.isNotEmpty(productList)) {
                    for (final Object products : productList) {
                        final String json = convertObjectToJSON(products);
                        final JsonObject productJson = new JsonParser().parse(json).getAsJsonObject();
                        final String productName = JsonUtil.getStringValueFromJson(productJson,
                                JsonPathQuery.PRODUCT_TITLE.query());
                        final int quantity = JsonUtil.getIntValueFromJson(productJson,
                                JsonPathQuery.LINEITEM_QUANTITY.query());
                        final int productPrice = JsonUtil.getIntValueFromJson(productJson,
                                JsonPathQuery.LINEITEM_PRICE.query()) * quantity;
                        final String displayPrice = getProductPrice(productPrice);
                        final JSONArray productImage = JsonUtil.getArrayValueFromJson(productJson,
                                JsonPathQuery.LINEITEM_IMAGE.query());
                        final String imagePath = productImage.get(0).toString();
                        final String productQuantity = quantity > 1 ? " (" + quantity + ")" : "";
                        final int discountedPricePerLineItem = JsonUtil.getIntValueFromJson(productJson,
                                JsonPathQuery.LINEITEM_DISCOUNT_PRICE.query());
                        discountAmount = discountAmount + (discountedPricePerLineItem * quantity);
                        htmlBuilder.append(" <tr>\r\n"
                                + "                                                    <td class=\"\"\r\n"
                                + "                                                        style=\"font-size: 2px; line-height: 2px; text-decoration: none;\">\r\n"
                                + "                                                        <table class=\"\" role=\"presentation\"\r\n"
                                + "                                                            style=\"mso-cellspacing: 0; mso-padding-alt: 0;\"\r\n"
                                + "                                                            align=\"center\" width=\"100%\" cellspacing=\"0\" cellpadding=\"0\"\r\n"
                                + "                                                            border=\"0\">\r\n"
                                + "                                                            <tbody>\r\n"
                                + "                                                                <tr>\r\n"
                                + "                                                                    <td class=\"\" aria-hidden=\"true\"\r\n"
                                + "                                                                        style=\"font-size: 2px; line-height: 2px; width: 40px;\"\r\n"
                                + "                                                                        align=\"left\" width=\"40\" valign=\"middle\"><img\r\n"
                                + "                                                                        class=\"\"\r\n"
                                + "                                                                        src=\""
                                + imagePath + "\"\r\n"
                                + "                                                                        style=\"display: block;\" alt=\"\" width=\"40\"\r\n"
                                + "                                                                        border=\"0\"></td>\r\n"
                                + "                                                                    <td class=\"fbtxt\"\r\n"
                                + "                                                                        style=\"color: #262626; font-family: 'BMW-Light', Arial, sans-serif; font-size: 16px; font-weight: normal; line-height: 24px; padding-left: 15px; padding-right: 10px;\"\r\n"
                                + "                                                                        align=\"left\" width=\"100%\" valign=\"middle\">\r\n"
                                + "                                                                        <span class=\"fbtxt\"\r\n"
                                + "                                                                        style=\"color: #262626; font-family: 'BMW-Light', Arial, sans-serif; font-size: 16px; font-weight: normal; line-height: 24px; text-decoration: none;\">\r\n"
                                + productName + productQuantity + "</span>\r\n"
                                + "                                                                    </td>\r\n"
                                + "                                                                    <td class=\"fbtxt\"\r\n"
                                + "                                                                        style=\"color: #262626; font-family: 'BMW-Light', Arial, sans-serif; font-size: 16px; font-weight: normal; line-height: 24px; min-width: 40px;\"\r\n"
                                + "                                                                        align=\"right\" valign=\"middle\"><span\r\n"
                                + "                                                                        class=\"fbtxt\"\r\n"
                                + "                                                                        style=\"color: #262626; font-family: 'BMW-Light', Arial, sans-serif; font-size: 16px; font-weight: normal; line-height: 24px; text-decoration: none;\">\r\n"
                                + displayPrice + " </span></td>\r\n"
                                + "                                                                </tr>\r\n"
                                + "                                                            </tbody>\r\n"
                                + "                                                        </table>\r\n"
                                + "                                                    </td>\r\n"
                                + "                                                </tr>" + "<tr>\r\n"
                                + "                            <td class=\"\" style=\"font-size: 4px; line-height: 8px; text-decoration: none; height:8px;\" height=\"8\">&nbsp;</td>\r\n"
                                + "                          </tr>\r\n" + "\r\n" + "<tr>\r\n"
                                + "                            <td class=\"\" style=\"font-size: 4px; line-height: 8px; text-decoration: none; height:8px; border-top: 1px solid #e6e6e6;\" height=\"8\">&nbsp;</td>\r\n"
                                + "                          </tr>");
                    }
                }

                final int subTotal = (totalProductPrice - shippingAmount) + discountAmount;
                orderEmailParams.put(ORDER_PRODUCTS_DATA, htmlBuilder.toString());
                orderEmailParams.put(ORDER_SUBTOTAL, getProductPrice(subTotal));
                orderEmailParams.put(ORDER_PROMO_AMOUNT, getProductPrice(discountAmount));
                final String domainName = SHOP_PUBLISH_DOMAIN.replace("brand", brand);
                orderEmailParams.put(DOMAIN_URL, externalizer.externalLink(resourceResolver, domainName, "/"));
                setDealerDetails(orderEmailParams, dealerKey, brand);
            }
        } catch (final CryptoException | InterruptedException e) {
            throw new GenericException("Exception while fetching order confirmation email params", e);

        }
        LOG.debug("Exiting getOrderEmailParameters method");

        return orderEmailParams;
    }

    /**
     * This method will set the dealer price
     *
     * @param productKey
     * @param dealerCode
     * @param brand
     * @param productCard
     * @throws GenericException
     */
    @Override
    public void setDealerPrice(final String dealerCode, final String brand, final ProductDetails productCard)
            throws GenericException {

        LOG.debug("inside setDealerPrice method");

        if (StringUtils.isNoneEmpty(dealerCode) && !"null".equalsIgnoreCase(dealerCode)
                && !productCard.getKey().contains("xx") && !productCard.isLTO()) {
            final int dealerPrice = getDealerPrice(brand, dealerCode, productCard.getKey());
            if (dealerPrice != ZERO) {
                final Map<String, Object> prices = productCard.getPrices() != null ? productCard.getPrices()
                        : new HashMap<>();
                prices.put(DISPLAY, dealerPrice);
                prices.put(CURRENCY_CODE_KEY, CURRENCY_CODE);
                prices.put(PRICE_TYPE_KEY, PRICE_TYPE);
                productCard.setCentAmount(dealerPrice);
                productCard.setPrices(prices);
            }
        }
        LOG.debug("exiting setDealerPrice method");

    }

    /**
     * This method will set the Price Range for Master Variant.
     *
     * @param productCard
     */
    @Override
    public void setPriceRangeProdDetailsForMasterVariant(final ProductDetails productCard) {

        LOG.debug("inside setPriceRangeProdDetailsForMasterVariant method");
        final List<ProductDetails> variants = productCard.getVariants();
        final StringBuilder stringBuilder = new StringBuilder();
        final List<String> typeKeyList = CollectionUtils.isNotEmpty(productCard.getTypeKey()) ? productCard.getTypeKey()
                : new ArrayList<>();
        int min = Integer.MAX_VALUE;
        int max = 0;
        final HashMap<String, Object> prices = new HashMap<>();
        for (final ProductDetails variant : variants) {
            stringBuilder.append(variant.getProductPartDetails() + " <br>");
            if (variant.getItemNumber().contains("xx") && (variant.getMaxCentAmount() != null)
                    && (variant.getMinCentAmount() != null)) {
                if (min > variant.getMinCentAmount()) {
                    min = variant.getMinCentAmount();
                }
                if ((max < variant.getMaxCentAmount())) {
                    max = variant.getMaxCentAmount();
                }
                productCard.setMaxCentAmount(max);
                productCard.setMinCentAmount(min);
                // these fields were only used for calculation hence setting these fields null
                // as not needed to send back in json.
                variant.setMaxCentAmount(null);
                variant.setMinCentAmount(null);

            }

            typeKeyList.addAll(variant.getTypeKey());
            if ((variant.getPrices() != null) && variant.getPrices().containsKey(CURRENCY_CODE_KEY)
                    && variant.getPrices().containsKey(PRICE_TYPE_KEY)) {
                prices.put(CURRENCY_CODE_KEY, variant.getPrices().get(CURRENCY_CODE_KEY).toString());
                prices.put(PRICE_TYPE_KEY, variant.getPrices().get(PRICE_TYPE_KEY).toString());
            }
        }
        final List<String> newTypeKeyList = CollectionUtils.isNotEmpty(typeKeyList)
                ? typeKeyList.stream().distinct().collect(Collectors.toList())
                : null;
        productCard.setProductPartDetails(stringBuilder.toString().replace("<br> <br>", "<br>"));
        productCard.setTypeKey(newTypeKeyList);
        setLtoPriceRangeProdDetailsForMasterVariant(productCard);
        setPriceRangeForParentLevel(productCard, prices);
        // these fields were only used for calculation hence setting these fields null
        // as not needed to send back in json.
        productCard.setMaxCentAmount(null);
        productCard.setMinCentAmount(null);

    }

    /**
     * This method will set the child variants.
     *
     * @param modelCode
     * @param dealerCode
     * @param productCard
     * @param serviceResponse
     * @throws GenericException
     */
    @Override
    public void setProductVariants(final String dealerCode, final ProductDetails productCard,
            final JsonObject serviceResponse, final String brand) throws GenericException {

        LOG.debug("inside setProductVariants method");
        if (productCard.getItemNumber().contains("xx")) {
            try {
                final HashMap<String, Object> prices = new HashMap<>();
                final StringBuilder stringBuilder = new StringBuilder();
                final List<String> typeKeyList = CollectionUtils.isNotEmpty(productCard.getTypeKey())
                        ? productCard.getTypeKey()
                        : new ArrayList<>();
                LOG.debug("setting variants for product {}", productCard.getItemNumber());
                final String productVariantsApiEndpoint = GlobalUtil.getConfig(brand,
                        oneShopApiConfig.getProductProjectionApiEndpoint())
                        + GlobalUtil.getConfig(brand, oneShopApiConfig.getProductVariants());
                final String productFilterByVariantsEndpoint = MessageFormat.format(productVariantsApiEndpoint,
                        productCard.getItemNumber());
                LOG.debug("productFilterByVariantsEndpoint{}", productFilterByVariantsEndpoint);
                final String[] productQueryParams = productFilterByVariantsEndpoint
                        .split(Constants.QUESTION_MARK_DELIMITER);
                final HashMap<String, String> queryMap = (HashMap<String, String>) generateCategoryQueryParams(
                        productQueryParams);
                final RestServiceConfiguration serviceConfig = getServiceConfig(brand);
                serviceConfig.setServiceEndpoint(productQueryParams[0]);
                final RestServiceRequest variantRestServiceRequest = new RestServiceRequest(serviceConfig, queryMap);
                final JsonObject variantsResponse = executeOneShopGetRequest(variantRestServiceRequest, brand);
                if (ObjectUtils.isNotEmpty(variantsResponse) && (serviceResponse.size() > 0)) {
                    setVariantInformation(dealerCode, productCard, serviceResponse, prices, stringBuilder, typeKeyList,
                            variantsResponse, brand);
                }
            } catch (final CryptoException cryptoException) {
                throw new GenericException("Crypto Exception while getting products count for categories",
                        cryptoException);
            }

        }

        LOG.debug("Exiting setProductVariants method");

    }

    /**
     * This method will return RestServiceConfiguration object.
     *
     * @return
     */
    private RestServiceConfiguration getServiceConfig(final String brand) throws CryptoException {

        LOG.debug("inside getServiceConfig method");
        final RestServiceConfiguration serviceConfig = new RestServiceConfiguration();
        serviceConfig.setXApiKey(cryptoSupport.isProtected(GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()))
                ? cryptoSupport.unprotect(GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()))
                : GlobalUtil.getConfig(brand, oneShopApiConfig.getApiKey()));
        serviceConfig.setMarket(GlobalUtil.getConfig(brand, oneShopApiConfig.getMarket()));
        serviceConfig.setEcpType(GlobalUtil.getConfig(brand, oneShopApiConfig.getEcpType()));
        serviceConfig.setHttpMethod(METHOD_GET);
        serviceConfig.setServiceUrl(GlobalUtil.getConfig(brand, oneShopApiConfig.getServiceUrl()));

        return serviceConfig;
    }

    /**
     * This method will fetch dealer details from oneshop based on dealer key
     *
     * @param orderEmailParams
     * @param dealerKey
     * @throws CryptoException
     * @throws GenericException
     */
    private void setDealerDetails(final Map<String, String> orderEmailParams, final String dealerKey,
            final String brand) throws CryptoException, GenericException {

        LOG.debug("Inside setDealerDetails method");
        final String channelsApiEndPoint = MessageFormat
                .format(GlobalUtil.getConfig(brand, oneShopApiConfig.getChannels()), ZERO)
                + MessageFormat.format(FILTER_DEALER_KEY, dealerKey);
        final RestServiceConfiguration channelsServiceConfig = getServiceConfig(brand);
        channelsServiceConfig.setServiceEndpoint(channelsApiEndPoint);
        final RestServiceRequest restServiceRequestChannel = new RestServiceRequest(channelsServiceConfig, null);
        final JsonObject channelsServiceResponse = executeOneShopGetRequest(restServiceRequestChannel, brand);
        if ((null != channelsServiceResponse) && ObjectUtils.isNotEmpty(channelsServiceResponse)) {
            orderEmailParams.put(DEALER_NAME_PARAM,
                    JsonUtil.getStringValueFromJson(channelsServiceResponse, JsonPathQuery.DEALER_NAME.query()));
            orderEmailParams.put(DEALER_EMAIL,
                    JsonUtil.getStringValueFromJson(channelsServiceResponse, JsonPathQuery.DEALER_EMAIL.query()));
            orderEmailParams.put(DEALER_ADDRESS_STREET, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_STREET.query()));
            orderEmailParams.put(DEALER_ADDRESS_POSTALCODE, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_POSTALCODE.query()));
            orderEmailParams.put(DEALER_ADDRESS_CITY, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_CITY.query()));
            orderEmailParams.put(DEALER_ADDRESS_STATE, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_STATE.query()));
            orderEmailParams.put(DEALER_ADDRESS_COUNTRY, JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_COUNTRY.query()));
            final String dealerPhoneNumber = JsonUtil.getStringValueFromJson(channelsServiceResponse,
                    JsonPathQuery.DEALER_ADDRESS_PHONENUMBER.query());
            orderEmailParams.put(DEALER_ADDRESS_PHONENUMBER, getFormattedPhoneNumber(dealerPhoneNumber));
        }
    }

    /**
     * This method will set the LTO Price Range for Master Variant.
     *
     * @param productCard
     */
    private void setLtoPriceRangeProdDetailsForMasterVariant(final ProductDetails productCard) {

        LOG.debug("inside setLtoPriceRangeProdDetailsForMasterVariant method");
        final List<ProductDetails> variants = productCard.getVariants();
        int ltoMin = Integer.MAX_VALUE;
        int ltoMax = 0;
        boolean childAvailable = false;
        for (final ProductDetails variant : variants) {
            if (variant.getItemNumber().contains("xx") && (variant.getStrikeoutMaxCentAmount() != null)
                    && (variant.getStrikeoutMinCentAmount() != null)) {
                if (ltoMin > variant.getStrikeoutMinCentAmount()) {
                    ltoMin = variant.getStrikeoutMinCentAmount();
                }
                if ((ltoMax < variant.getStrikeoutMaxCentAmount())) {
                    ltoMax = variant.getStrikeoutMaxCentAmount();
                }
                productCard.setStrikeoutMaxCentAmount(ltoMax);
                productCard.setStrikeoutMinCentAmount(ltoMin);
                // these fields were only used for calculation hence setting these fields null
                // as not needed to send back in json.
                variant.setStrikeoutMaxCentAmount(null);
                variant.setStrikeoutMinCentAmount(null);
            }
            if (variant.isAvailability()) {
                childAvailable = true;
            }
        }
        // these fields were only used for calculation hence setting these fields null
        // as not needed to send back in json.
        productCard.setStrikeoutMaxCentAmount(null);
        productCard.setStrikeoutMinCentAmount(null);
        productCard.setAvailability(childAvailable);
    }

    /**
     * This method will set max min price for strikeout.
     *
     * @param productCard
     * @param productVariantCard
     */
    private void setMaxMinAmountForLTO(final ProductDetails productCard, final ProductDetails productVariantCard,
            int minStrikeout, int maxStrikeout) {

        LOG.debug("inside setMaxMinAmountForLTO method");
        if (minStrikeout > productVariantCard.getStrikeoutCentAmount()) {
            minStrikeout = productVariantCard.getStrikeoutCentAmount();
        }
        if ((maxStrikeout < productVariantCard.getStrikeoutCentAmount()) && !productCard.isChildMultiSelect()) {
            maxStrikeout = productVariantCard.getStrikeoutCentAmount();
        } else if (productCard.isChildMultiSelect()) {
            maxStrikeout = maxStrikeout + productVariantCard.getStrikeoutCentAmount();
        }

        productCard.setStrikeoutMaxCentAmount(maxStrikeout);
        productCard.setStrikeoutMinCentAmount(minStrikeout);
        productVariantCard.setStrikeoutCentAmount(null);
    }

    /**
     * This method will set the max and min price for variant levels.
     *
     * @param productCard
     * @param productVariantCard
     */
    private void setMaxMinPriceForVariant(final ProductDetails productCard, final ProductDetails productVariantCard,
            int min, int max) {

        LOG.debug("inside setMaxMinPriceForVariant method");
        if (min > productVariantCard.getCentAmount()) {
            min = productVariantCard.getCentAmount();
        }
        if ((max < productVariantCard.getCentAmount()) && !productCard.isChildMultiSelect()) {
            max = productVariantCard.getCentAmount();
        } else if (productCard.isChildMultiSelect()) {
            max = max + productVariantCard.getCentAmount();
        }

        productCard.setMaxCentAmount(max);
        productCard.setMinCentAmount(min);

        // these fields were only used for calculation hence setting these fields null
        // as not needed to send back in json.
        productVariantCard.setCentAmount(null);
    }

    /**
     * This method will set Price range for parent level.
     *
     * @param productCard
     */
    private void setPriceRangeForParentLevel(final ProductDetails productCard, final HashMap<String, Object> prices) {

        LOG.debug("inside setPriceRangeForParentLevel method");
        if ((productCard.getMinCentAmount() != null) && (productCard.getMaxCentAmount() != null)
                && productCard.getMaxCentAmount().equals(productCard.getMinCentAmount())) {
            prices.put(DISPLAY, productCard.getMaxCentAmount());
        } else if ((productCard.getMinCentAmount() != null) && (productCard.getMaxCentAmount() != null)
                && !productCard.getMaxCentAmount().equals(productCard.getMinCentAmount())) {
            prices.put(DISPLAY, productCard.getMinCentAmount());
            prices.put(MAX_DISPLAY_PRICE, productCard.getMaxCentAmount());
        }
        setStrikeoutPriceRangeForParentLevel(productCard, prices);
        productCard.setPrices(prices);

    }

    /**
     * This method will set Strikeout Price range for parent level.
     *
     * @param productCard
     */
    private void setStrikeoutPriceRangeForParentLevel(final ProductDetails productCard,
            final HashMap<String, Object> prices) {

        LOG.debug("inside setStrikeoutPriceRangeForParentLevel method");
        if ((productCard.getStrikeoutMinCentAmount() != null) && (productCard.getStrikeoutMaxCentAmount() != null)
                && productCard.getStrikeoutMaxCentAmount().equals(productCard.getStrikeoutMinCentAmount())) {
            prices.put(STRIKE_OUT, productCard.getStrikeoutMaxCentAmount());
        } else if ((productCard.getStrikeoutMinCentAmount() != null)
                && (productCard.getStrikeoutMaxCentAmount() != null)
                && !productCard.getStrikeoutMaxCentAmount().equals(productCard.getStrikeoutMinCentAmount())) {
            prices.put(STRIKE_OUT, productCard.getMinCentAmount());
            prices.put(MAX_STRIKEOUT_PRICE, productCard.getMaxCentAmount());
        }
    }

    /**
     * This method will set the variant details.
     *
     * @param dealerCode
     * @param productCard
     * @param serviceResponse
     * @param prices
     * @param stringBuilder
     * @param typeKeyList
     * @param variantsResponse
     * @throws GenericException
     */
    private void setVariantInformation(final String dealerCode, final ProductDetails productCard,
            final JsonObject serviceResponse, final HashMap<String, Object> prices, final StringBuilder stringBuilder,
            final List<String> typeKeyList, final JsonObject variantsResponse, final String brand)
            throws GenericException {

        LOG.debug("inside setVariantInformation method");
        final List<ProductDetails> productVariantList = new ArrayList<>();
        final JsonArray results = variantsResponse.getAsJsonArray(Constants.RESULTS);
        int min = Integer.MAX_VALUE;
        int max = 0;
        int minStrikeout = Integer.MAX_VALUE;
        int maxStrikeout = 0;
        boolean childAvailable = false;
        for (final JsonElement element : results) {
            final JsonObject productJson = element.getAsJsonObject();
            if (ObjectUtils.isNotEmpty(productJson)) {
                final ProductDetails productVariantCard = generateProductDetailResponse(productJson);
                setDealerPrice(dealerCode, brand, productVariantCard);
                productVariantList.add(productVariantCard);
                prices.put(CURRENCY_CODE_KEY, CURRENCY_CODE);
                prices.put(PRICE_TYPE_KEY, PRICE_TYPE);
                stringBuilder.append(productVariantCard.getProductPartDetails() + " <br>");
                typeKeyList.addAll(productVariantCard.getTypeKey());
                if (productVariantCard.isAvailability()) {
                    childAvailable = true;
                }
                if (!productVariantCard.getItemNumber().contains("xx")
                        && (productVariantCard.getCentAmount() != null)) {
                    setMaxMinPriceForVariant(productCard, productVariantCard, min, max);
                    min = productCard.getMinCentAmount();
                    max = productCard.getMaxCentAmount();
                    if (productVariantCard.getStrikeoutCentAmount() != null) {
                        setMaxMinAmountForLTO(productCard, productVariantCard, minStrikeout, maxStrikeout);
                        maxStrikeout = productCard.getStrikeoutMaxCentAmount();
                        minStrikeout = productCard.getStrikeoutMinCentAmount();
                    }
                }

                setProductVariants(dealerCode, productVariantCard, serviceResponse, brand);

            }
        }
        productCard.setAvailability(childAvailable);
        setPriceRangeForParentLevel(productCard, prices);
        productCard.setProductPartDetails(stringBuilder.toString().replace("<br> <br>", "<br>"));
        productCard.setVariants(productVariantList);
        productCard.setTypeKey(typeKeyList);
    }

}
